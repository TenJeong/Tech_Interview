# HTTP

## 2.5.1 HTTP/1.0
- `한 연결당` `하나의 요청`을 처리하도록 설계  
- HTTP 응답 시간 : 2RTT (TCP connection, response time) + file transmission time
  → RTT 증가를 초래
  - ❓RTT란 ? 패킷 왕복 시간, 패킷이 목적지에 도달하고 나서 다시 출발지로 돌아오기까지 걸리는 시간

### RTT의 증가를 해결하기 위한 방법
1. **이미지 스플리팅**
   - 많은 이미지를 다운로드받게 되면 과부하가 걸림 
   → 많은 이미지가 합쳐 있는 하나의 이미지를 다운로드받고, 이를 기반으로 background-image의 position을 이용하여 이미지를 표기

2. **코드 압축**
   - 코드를 압축해서 개행 문자, 빈칸을 없애서 코드의 크기를 최소화하는 방식

3. **이미지 Base64 인코딩**
   - 이미지 파일을 64진법으로 이루어진 문자열로 인코딩하는 방법
   - 💡 **장점** : 이미지에 대해 서버에 따로 HTTP 요청을 할 필요가 없다.
   - 🚨 **단점** : Base64 문자열로 변환할 경우 37% 정도 크기가 더 커짐.


## 2.5.2 HTTP/1.1
- 매번 TCP 연결을 하는 것이 아니라 한 번 TCP 초기화를 한 후에 `keep-alive 옵션`으로 여러 개의 파일을 송수신할 수 있게 함.
- TCP 연결을 종료하지 않으려면 `Connection: Keep-Alive`
- 연결을 종료하고 싶다면 `Connection: Close`  
- 🚨 하지만 문서 안에 포함된 다수의 리소스를 처리하려면 요청할 리소스 개수에 비례해서 대기 시간이 길어짐.

### HOL Blocking
- 네트워크에서 같은 큐에 있는 패킷이 그 첫 번째 패킷에 의해 지연될 때 발생하는 성능 저하 현상
- 웹서버는 Pipelining 을 통해 한 번에 여러 개의 요청을 받을 수 있으나, 응답 순서는 요청 순에 따라야 함.
- 따라서, 앞의 패킷에 의해 지연이 발생할 때는 뒤에 아무리 빨리 처리할 수 있는 패킷이 있더라도 앞의 패킷이 모두 처리한 후에야 응답을 처리할 수 있다.

### 무거운 헤더 구조
쿠키 등 많은 메타데이터가 들어 있고 압축이 되지 않아 무거움.

## 2.5.3 HTTP/2
- HTTP/1.x 보다 지연 시간을 줄이고 응답 시간을 더 빠르게 할 수 있으며 `멀티 플렉싱, 헤더 압축, 서버 푸시, 요청의 우선순위 처리` 를 지원

### 멀티플렉싱
- 하나의 연결 내에 여러 개의 스트림을 사용하여 송수신한다는 것
- 특정 스트림의 패킷이 손실되었다고 하더라도 해당 스트림에만 영향을 미치고 나머지 스트림은 정상 동작할 수있음.
- 단일 연결을 사용하여 병렬로 여러 요청을 받을 수 있고 응답을 줄 수 있음.

1. http 메시지를 독립적인 작은 개별 프레임으로 나누어 전송
2. 목적지에 도착하였을 때 재조립
  💡 HTTP/1.x 에서 발생하는 문제인 `HOL Blocking`을 해결 가능

### 헤더 압축
- HTTP/1.x 의 무거운 헤더 문제를 헤더 압축으로 해결
- 허프만 코딩 압축 알고리즘을 사용하여 HPACK 압축 형식을 가짐.
#### 허프만 코딩
- 문자열을 문자 단위로 쪼개 빈도수를 세어 빈도가 높은 정보는 적은 비트 수를 사용하여 표현
- 빈도가 낮은 정보는 비트 수를 많이 사용하여 표현해서 전체 데이터의 표현에 필요한 비트양을 줄이는 원리

### 서버 푸시
- 클라이언트가 요청하지 않아도 서버에서 데이터 전송 가능
- HTTP/1.1 에서는 클라이언트가 서버에 요청을 해야 파일을 다운로드 받을 수 있었다면, HTTP/2 는 클라이언트 요청 없이 서버가 바로 리소스를 푸시할 수 있음.
- ex) html에는 css나 js 파일이 포함되기 마련인데 html을 읽으면서 그 안에 들어 있던 css 파일을 서버에서 푸시하여 클라이언트에게 먼저 줄 수 있음.

[참고](https://seo-tory.tistory.com/82)


## 2.5.4 HTTPS
- HTTP/2 는 HTTPS 위에서 동작
- `HTTPS` : 애플리케이션 계층과 전송 계층 사이에 신뢰 계층인 `SSL/TLS 계층`을 넣은 신뢰할 수 있는 HTTP 요청을 말함
### SSL/TLS
  - 전송 계층에서 보안을 제공하는 프로토콜
  - 클라이언트와 서버가 통신할 때 SSL/TLS를 통해 제 3자가 메시지를 도청하거나 변조하지 못하게 함.
    - SSL/TLS를 통해 공격자가 서버인 척하며 사용자 정보를 가로채는 네트워크상의 `인터셉터`를 방지할 수 있음.
  - 보안 세션을 기반으로 데이터를 암호화, 보안 세션이 만들어질 때 인증 메커니즘, 키 교환 암호화 알고리즘, 해싱 알고리즘이 사용됨.
  #### 보안 세션
  - 보안이 시작되고 끝나는 동안 유지되는 세션
  - SSL/TLS 는 핸드셰이크를 통해 보안 세션을 저장하고 이를 기반으로 상태 정보 공유
  #### 세션
  - 운영체제가 어떠한 사용자로부터 자신의 자산 이용을 허락하는 일정한 기간을 뜻함.
    - 사용자는 일정 시간 동안 응용 프로그램, 자원 등을 사용할 수 있음.

### TLS의 핸드셰이크
1. 클라이언트에서 `사이퍼 슈트`를 서버에 전달
2. 서버는 받은 사이퍼 슈트의 암호화 알고리즘 리스트를 제공할 수 있는지 확인
3. 제공할 수 있다면 서버에서 클라이언트로 `인증서`를 보내는 인증 메커니즘이 시작되고 이후 암호화된 데이터의 송수신이 시작됨.
  #### 사이퍼 슈트
  - 프로토콜, AEAD 사이퍼 모드, 해싱 알고리즘이 나열된 규약
  - `TLS_AES_128_GCM_SHA256` 
    - TLS : 프로토콜
    - AES_128_GCM : AEAD 사이퍼 모드
    - SHA256 : 해싱 알고리즘
  #### AEAD 사이퍼 모드
  - 데이터 암호화 알고리즘

### 인증 메커니즘
- CA (Certificate Authorities) 에서 발급한 인증서를 기반을 이루어짐.
- CA 에서 발급한 인증서는 안전한 연결을 시작하는 데 있어 필요한 공개키를 클라이언트에 제공하고 사용자가 접속한 '서버가 신뢰'할 수 있는 서버임을 보장
  #### CA 발급 과정
  - CA는 공개키를 해시한 값인 지문을 사용하는 CA의 비밀 키 등을 기반으로 CA 인증서를 발급

### 암호화 알고리즘
- ECDHE, DHE를 사용 (모두 `디피-헬만 방식`을 근간으로 만들어짐)
  #### 디피-헬만 키 교환 암호화 알고리즘
  - 

### 해싱 알고리즘
- SSL/TLS는 해싱 알고리즘으로 SHA-256, SHA-384 알고리즘 사용
  - SHA-256 알고리즘

### SEO에도 도움이 되는 HTTPS
- SEO(Search Engine Optimization) : 검색엔진 최적화
1. 캐노니컬 설정
2. 메타 설정
   - html 파일의 가장 윗부분인 메타를 잘 설정해야 함.
3. 페이지 속도 개선
   - 사이트의 속도는 빨라야 함.
4. 사이트맵 관리

### HTTPS 구축 방법
1. 직접 CA에서 구매한 인증키를 기반으로 HTTPS 서비스를 구축
2. 서버 앞단의 HTTPS를 제공하는 로드밸런서를 둠.
3. 서버 앞단에 HTTPS를 제공하는 CDN을 둠


##  2.5.5 HTTP/3
- TCP에서 돌아가는 HTTP/2와는 달리 HTTP/3은 QUIC이라는 계층 위에서 돌아감.
- TCP 기반이 아닌 UDP 기반으로 돌아감.  
💡 **장점**  
- HTTP/2의 장점이었던 멀티플렉싱을 가지고 있음.
- 초기 연결 설정 시 지연 시간 감소

### 초기 연결 설정 시 지연 시간 감소
1. QUIC은 TCP를 사용하지 않기 때문에 통신을 시작할 때 3-way handshaking 과정을 거치지 않아도 됨.
2. QUIC 은 첫 연결 설정에 `1-RTT`만 소요됨. (TCP + TLS : 3RTT)
3. QUIC 은 순방향 오류 수정 메커니즘 (FEC, Forword Error Correction)이 적용됨.
   (패킷이 손실되었다면 수신 측에서 에러를 검춣하고 수정하는 방식, 낮은 패킷 손실률을 자랑함.)

### 대칭 키와 비대칭 키
- `대칭 키` : 하나의 키로 데이터를 암호화하고 복호화함.
    - 💡 **장점** : 암호화 및 복호화에 드는 비용이 적다.
    - 🚨 **단점** : 대칭 키가 유출되면 키를 획득한 공격자는 암호화의 내용을 복호화할 수 있음.
- `비대칭 키` : 공개 키와 개인 키로 암호화 및 복호화를 수행 / 공개 키로 데이터를 암호화하면 개인 키로만 복호화 가능, 개인 키로 데이터를 암호화하면 공개 키로만 복호화할 수 있음, 
  - 💡 **장점** : 보안성이 좋음.
  - 🚨 **단점** : 구현하기 어렵고 암호화 및 복호화 속도가 느림.
