# Chapter 4: 데이터베이스
## Section 4.5: 인덱스
### 4.5.1 인덱스의 필요성
- 인덱스는 데이터를 빠르게 찾을 수 있는 하나의 장치이다.

### 4.5.2 B-트리
- 인덱스는 보통 B-트리로 이루어져 있다.
- 바로 데이터의 값을 탐색하는 것이 아닌, 루프 노드에서 브랜치 노드를 통해 리프노드의 데이터포인터를 이용하여 접근한다.

#### 인덱스가 효율적인 이유와 대수확장성
- 인덱스의 효율성은 모든 요소에 접근할 수 있는 균형 잡힌 트리 구조와 트리 깊이의 대수확장성 때문이다.
  - 대수확장성: 트리 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 것을 말한다.
  - 기본적으로 인덱스가 한 깊이씩 증가할 때마다 최대 인덱스 항목의 수는 4배씩 증가한다.

### 4.5.3 인덱스 만드는 방법
#### MySQL
- MySQL에는 클러스터형 인덱스와 세컨더리 인덱스가 있다.
  - primary key 옵션으로 기본키를 만들면 클러스터형 인덱스를 생성할 수 있고, 기본키를 만들지 않고 unique not null 옵션을 붙이면 클러스터형 인덱스로 만들 수 있다.
  - "create index ..." 명령어를 사용하면 세컨더리 인덱스를 만들 수 있다.
- 클러스터형 인덱스는 테이블 당 하나를 설정할 수 있다.
- 하나의 인덱스만 생성한다면 클러스터형 인덱스를 만드는 것이 세컨더리 인덱스를 만드는 것보다 성능이 좋다.
- 세컨더리 인덱스는 보조 인덱스로 여러 개의 필드 값을 기반으로 쿼리를 많이 보낼 때 생성해야 하는 인덱스이다.

#### MongoDB
- MongoDB에서는 도큐먼트를 만들면 자동으로 ObjectID가 생성되며, 이 키가 기본키로 설정된다.
- 세컨더리키도 부가적으로 설정해서 기본키와 세컨더리키를 같이 쓰는 복합 인덱스를 설정할 수 있다.

### 4.5.4 인덱스 최적화 기법
- 인덱스 최적화 기법은 데이터베이스마다 조금씩 다르지만 기본적인 골조는 동일하다.

#### 인덱스는 결국 비용인 것을 감안하자
- 인덱스는 인덱스 리스트, 컬렉션 순으로 탐색하기 때문에 두 번 탐색을 강요한다.
- 컬렉션이 수정되었을 때 인덱스도 수정되어야 한다. 이때 B-트리의 높이를 균형 있게 조절하는 비용이 들고 데이터를 효율적으로 조회할 수 있도록 분산시키는 비용도 든다.
- 따라서 쿼리에 있는 필드의 인덱스를 무작정 다 설정하는 것은 비효율적일 수 있다.

#### 인덱스 최적화는 항상 테스트로 확인하자
- 인덱스 최적화 기법은 서비스 특징에 따라 해당 서비스의 객체의 깊이, 테이블의 양 등에 의해 달라진다.
- 따라서 explain() 함수 등을 통해 인덱스를 만들고 쿼리를 보낸 후 테스팅하여 걸리는 시간을 최소화해야 한다.

#### 복합 인덱스는 "같음 -> 정렬 -> 다중 값 -> 카디널리티" 순으로 생성하자
- 복합 인덱스는 생성할 때 순서가 있고 생성 순서에 따라 인덱스 성능이 달라진다.
- 최적화를 위해서는 "같음 -> 정렬 -> 다중 값 -> 카디널리티" 순으로 생성해야 한다.
  1. 어떠한 값과 같음을 비교하는 '==' 또는 'equal'이라는 쿼리가 있다면 제일 먼저 인덱스로 설정한다.
  2. 정렬에 쓰는 필드라면 그 다음 인덱스로 설정한다.
  3. 다중 값을 출력해야 하는 필드, 즉 쿼리 자체가 '>' 또는 '<' 등 많은 값을 출력해야 하는 쿼리에 쓰는 필드라면 나중에 인덱스를 설정한다.
  4. 카디널리티(유니크한 값의 정도)가 높은 순서를 기반으로 인덱스를 생성해야한다.