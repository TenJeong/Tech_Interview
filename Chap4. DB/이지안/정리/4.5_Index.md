# 4.5 인덱스

## 4.5.1 인덱스의 필요성
- 인덱스는 데이터를 빠르게 찾을 수 있는 하나의 장치이다.

## 4.5.2 B-트리
- 보통 인덱스는 B-트리라는 자료 구조로 이루어져 있음.
### 인덱스가 효율적인 이유와 대수확장성
- `대수확장성`
  - 트리 깊이가 리프 노드 수에 비해 매우 느리게 성장함.
  - 기본적으로 인덱스가 한 깊이씩 증가할 때마다 최대 인덱스 항목의 수는 4배씩 증가함.

## 4.5.3 인덱스 만드는 방법
- 인덱스를 만드는 방법은 데이터베이스마다 다릅니다.
- **MySQL**
  - `클러스터형 인덱스`: 1. primary key 옵션으로 기본키로 만들거나 2. unique not null 옵션을 붙이면 클러스터형 인덱스를 생성할 수 있다.
    - 테이블당 1개만 존재할 수 있음.
    - 기본 키로 지정된 칼럼은 자동으로 클러스터링 인덱스가 생성됨.
    - 클러스터링 인덱스를 기준으로 데이터가 자동 정렬
  - `세컨더리 인덱스` : create index ... 명령어를 기반으로 세컨더리 인덱스를 만들 수 있음.
    - Primary Key 이외에 필요한 정렬 기준이 있을 경우 사용한다.
    - 테이블당 여러 개 가질 수 있다.
  - 클러스터형 인덱스를 만드는 것이 세컨더리 인덱스를 만드는 것보다 성능이 좋음.
  - 세컨더리 인덱스는 보조 인덱스로 여러 개의 필드 값을 기반으로 쿼리를 많이 보낼 때 생성해야 하는 인덱스임.
- **MongoDB**
  - 도큐먼트를 만들면 자동으로 ObjectID가 형성되며, 해당 키가 기본키로 설정됨.
  - 기본키와 세컨더리키를 같이 쓰는 복합 인덱스를 설정할 수 있음.

## 4.5.4 인덱스 최적화 기법
**1. 인덱스는 비용이다.**
- 먼저 인덱스는 두 번 탐색하도록 강요함. (인덱스 리스트, 그다음 컬렉션)
- 컬렉션이 수정되었을 때, 인덱스도 수정되어야 함.
  - 한 컬렉션에서 가져와야 하는 양이 많을수록 인덱스를 사용하는 것은 비효율적
**2. 항상 테스팅하라**
- 인덱스 최적화 기법은 서비스 특징에 따라 달라짐.
- 서비스에서 사용하는 객체의 깊이, 테이블의 양 등이 다르기 때문에 테스팅하는 것이 중요
- `explain()` 함수를 통해 인덱스를 만들고 쿼리를 보낸 이후에 테스팅을 하며 걸리는 시간을 최소화해야 함.
```sql
EXPLAIN
SELECT * FROM t1
JOIN t2 ON t1.c1 = t2.c1
```

**3. 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순이다.**
- 보통 여러 필드를 기반으로 조회를 할 때 복합 인덱스를 생성
- 인덱스를 생성할 때는 순서가 있고 생성 순서에 따라 인덱스 성능이 달라짐.
> 1. 어떠한 값과 같음을 비교하는 쿼리에서 쓰는 필드
> 2. 정렬에 쓰는 필드
> 3. 많은 값을 출력해야 하는 쿼리에 쓰는 필드
> 4. 유니크한 값의 카디널리티가 높은 필드
