# 데이터베이스


- **데이터베이스에 정의는 무엇인가요?**
    
    일정한 규칙 또는 규약을 통해 구조화된 정보또는 데이터의 조직화된 모음을 의미합니다.
    

---

- **데이터베이스의 특징에 대해 설명해주세요**
    1. 실시간 접근성(Real-Time Accessiblity): 비정형적인 질의에 대하여 실시간 처리에 의한 응답이 가능해야한다.
    2. 지속적인 변화(Continous Evolution): 데이터베이스의 상태는 동적이며 새로운 데이터의 삽입, 삭제, 갱신으로 항상 최신의 데이터를 유지해야한다.
    3. 동시 공용(Concurrent Sharing): 데이터 베이스는 서로 다른 목적을 가진 여러 응용자들을 위한 것이므로 다수의 사용자가 동시에 같은 내용의 데이터를 이용할 수 있어야합니다.
    4. 내용에 의한 참고(Content Reference): 데이터베이스에 있는 데이터를 참조할때 데이터 레코드의 주소나 위치에 의해서가 아니라 사용자가 요구하는 데이터 내용으로 찾습니다.

---

- **DBMS의 정의는 무엇인가요?**
    
    DBMS는 데이터 베이스 관리 시스템을 나타냅니다. 사용자가 데이터에 관한 정보를 가능한 한 효율적이고 효과적으로 구성, 복원 및 검색 할 수 있도록하는 응용프로그램 모음을 의미합니다.
    

---

- **DBMS의 장점에 대해 설명해주세요.**
    - 데이터는 구조적으로 저장되므로 중복성이 제어됩니다.
    - 입력한 데이터의 유효성을 검사하고 데이터베이스에 대한 무단 액세스에 대한 제한을 제공합니다.
    - 필요한 경우 데이터 백업 및 복구를 제공합니다.
    - 여러 사용자 인터페이스를 제공합니다.

---

- **SQL에 대해 설명해주세요.**
    
    SQL문은 기본적으로 DDL, DML, DCL, TCL이 있습니다.
    
    DDL(Data Definition Language, 데이터 정의 언어): 데이터를 보유하는 구조를 정의하는데 사용되며 DDL은 자동 커밋됩니다. 즉 DDL에 의해 수행된 변경 사항이 영구적으로 저장됩니다.(create, drop..)
    
    DML(Data Manipulate Language, 데이터 조작 언어): 데이터베이스의 데이터를 조작하는데 사용되며 이 명령은 자동 커밋되지 않으며 롤백 할 수 있습니다.(insert, delete, update..)
    
    DCL(Data Controll Language, 데이터 제어 언어): 데이터베이스에서 데이터를 사용하기 위한 액세스 권한 취소와 같이 데이터베이스에서 데이터의 가시성을 제어하는 데 사용됩니다.(grant…)
    
    TCL(Transaction Controll Language): 데이터베이스에서 데이터의 보안, 무결성, 회복, 병행 수행제어 등을 정의하는데 사용됩니다.(commit, rollback..)
    

---

- **정규화와 비정규화에 대해 설명해주세요.**
    
    정규화는 하나의 릴레이션에 하나의 의미만 존재하도록 릴레이션을 분해하는 과정이며 데이터의 일관성, 최소한의 데이터 중복과 최대한의 데이터 유연성을 위한 방법입니다.
    
    비 정규화는 복잡한 쿼리 속도를 높이고 성능을 향상시키기 위 해 테이블에 중복 데이터를 추가하는 프로세스입니다.
    

---

- **정규화의 장점과 단점에 대해서 말씀해주세요.**
    
    장점은 데이터베이스 변경시 이상 현상을 제거하고, 데이터베이스 구조 확장시 재디자인을 최소화할 수 있다는 것이고 단점은 릴레이션 분해로 인해 릴레이션 간의 연산(join)이 많아져 응답시간이 느려질 수 있수있다는 것입니다.
    

---

- **제1정규형, 제2정규형, 제3정규형, 보이스/코드 정규형에 대해서 설명해주세요**
    
    제1정규형: 테이블의 컬럼이 원자 값을 갖도록 분해합니다.
    
    제2정규형: 제1정규형을 만족하고, 기본키가 아닌 속성이 기본키에 완전 함수 종속이도록 분해합니다.
    
    ➕ 결정자가 기본키이든 아니든 상관없이 완전 함수종속이도록 분해한다(즉 부분 함수 종속성을 없애는것을 목표로 한다.)
    
    제3정규형: 제2정규형을 만족하고 이행적 함수 종속을 없애도록 분해하는 것을 의미합니다.
    
    BCNF 정규형: 제 3정규형을 만족하고 함수 종속성 X → Y가 성립할 때 모든 결정자 X가 후보키가 되도록 분해합니다.
    

---

- **이상 현상의 정의와 종류에 대해 설명해주세요**
    
    이상 현상은 테이블을 설계할 떄 잘못 설계하여 데이터를 삽입, 삭제, 수정할 때 생기는 논리적 오류를 말합니다.
    
    1. 삽입 이상: 자료를 삽일할 때 특정 속성에 해당하는 값이 없어 NULL을 입력해야 하는 현상
    2. 갱신 이상: 중복된 데이터 중 일부만 수정되어 데이터 모순이 일어나는 현상
    3. 삭제 이상: 어떤 정보를 삭제하면, 의도하지 않는 다른 정보까지 삭제되어버리는 현상

---

- **트랜잭션의 정의와 무슨역할을 하는지 설명해주세요.**
    
    트랜잭션은 데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위를 의미합니다.
    
    트랜잭션은 커밋(commit)혹은 롤백(rollback)을 통해 작업의 완전성을 보장해 줍니다.
    

---

- **트랜잭션의 특성(ACID)에 대해 설명해주세요**
    1. 원자성(Atomicity): 작업이 모두 반영되거나 전형 반영되지 않아야 한다.
    2. 일관성(Consistency): 실행이 완료 되면 언제나 일관성 있는 상태를 유지해야 한다.
    3. 독립성(Isolation): 둘 이상 트랜잭션이 동시에 실행될 경우 서로의 연산에 끼어들 수 없다.
    4. 영속성(Durability): 완료된 결과는 영구적으로 반영되어야 한다.

---

- **데이터 베이스 격리수준의 정의 각 레벨에 대해서 설명해주세요.**
    
    트랜잭션에서 일관된 데이터를 허용하는 수준을 의미한다.
    
    1. Read Uncommited(Lv.0)
        - 임의의 트랜잭션에서 커밋하지 않은 내용을 다른 트랜잭션에서 읽는 것을 허용하는 단계이다.
        - Dirty Read가 발생할 수 있다.
        - Dirty Read : 다른 트랜잭션에 의해 수정되었지만 아직 커밋이 되지 않았음에도 불구하고 해당 데이터를 읽을수 있는 현상을 의미한다.
    2. Read Commited(Lv.1)
        - Commited된 데이터만 조회를 허용하는 것을 의미한다.
        - Non Repeatable read가 발생할 수 있습니다.
        - Non Repeatable read: 동일한 쿼리(조회)를 특정 트랜잭션 내부에서 두번 이상 수행시, 그 사이 다른 트랜잭션이 해당 데이터를 수정하고 커밋할 경우 다른 결과를 반환할 수 있다. / 같은 행의 데이터가 변경되어서 조회 가능
    3. Repeatable Read(Lv.2)
        - 트랜잭션 범위 내에서 조회한 내용이 항상 동일함을 보장하는 트랜잭션 격리 수준이다.
        - 트랜잭션은 각각 트랜잭션 번호가 존재하며, 이 번호는 순차적으로 증가하는 방식이다.
        - Repeatable Read에서 트랜잭션 ID보다 작은 트랜잭션 번호에서 변경된 것만 읽게 된다.
        - 그러나 이는 수정에 대해서만 적용되므로 삽입과 삭제에 대해서는 Phantom Read가 발생할 수 있다.
        - Phantom Read는 하나의 트랜잭션에서 동일한 쿼리(조회)를 보냈을때 기존의 결과값과 다른 다른 행이 추가되었거나 삭제되어서 조회되는 현상을 의미한다.
    4. Serializable(LV.3)
        - 위의 모든 문제를 해결한 격리수준이나 교착상태가 발생할 수 있고 가장 성능이 떨어지는 격리수준이다.

---

- **데이터 무결성의 정의와 종류에 대해서 설명해주세요**
    
    무결성이란 데이터의 정확성, 일관성, 유효성을 유지하는 것을 말한다.
    
    1. 개체 무결성: 기본키로 선택된 필드는 빈 값을 허용하지 않는다.
    2. 참조 무결성: 서로 참조관계에 있는 두 테이블의 데이터는 항상 일관된 값을 유지한다.
    3. 도메인 무결성: 테이블에 존재하는 필드의 무결성을 보장하기 위한 것으로 올바른 데이터가 입력됐는지를 체크하는 것이다.
    4. 고유 무결성: 특정속성에 대해 고유한 값을 가지도록 조건이 주어진 경우 그 속성값은 모두 고유한 값을 가진다.
    5. Null 무결성: 특정 속성값에 Null이 올 수 없다는 조건이 주어진 경우 그 속성값은 Null이 될 수 없다는 제약 조건
    6. 키 무결성: 한 릴레이션에는 최소한 하나의 키가 존재해야하는 제약조건

---

- **비관적 락과 낙관적 락에 대해서 설명해주세요**
    - 비관적 락
        - 정의 : 자원 요청에 따른 동시성 문제가 발생할 것이라고 예상하고 락을 걸어버리는 방법론
        - 특징
            - 트랜잭션의 충돌이 발생한다고 가정
            - 하나의 트랜잭션이 자원에 접근시 락을 걸고, 다른 트랜잭션이 접근하지 못하게 한다.
            - 데이터베이스에서 Shared Lock(공유, 읽기 잠금)이나 Exclusive Lock(베타, 쓰기잠금)을 겁니다.
        - 장점
            - 충돌이 자주 발생하는 환경에 대해서는 롤백의 횟수를 줄일 수 있으므로 성능에서 유리하다.
            - 데이터 무결성을 보장하는 수준이 매우 높습니다.
        - 단점
            - 데이터 자체에 락을 걸어버리므로 동시성이 떨어져 성능 손해를 많이 보게 됩니다. 특히 읽기가 많이 이루어지는 데이터베이스의 경우에는 손해가 더 두드러집니다.
            - 서로 자원이 필요한 경우에 락이 걸려있으므로 데드락이 일어날 가능성이 있습니다.
    - 낙관적 락
        - 정의 : 자원에 락을 걸어서 선점하지말고, 동시성 문제가 발생하면 그때 가서 처리 하자는 방법론
        - 특징
            - 트랜잭션의 충돌이 발생하지 않을것이라고 기대합니다.
            - 일단 충돌이 나는것을 막지 않고, 충돌이 난 것을 감지하면 그때 처리합니다.
            - 일반적으로 version의 상태를 보고 충돌을 확인하며, 충돌이 확인된 경우 롤백을 진행시키비다. (hashcode나 timestamp를 이용해서 충돌을 확인할 수도 있습니다.)
            - DB단에서 동시성을 처리하는 것이 아닌 어플리케이션단에서 처리 합니다.
            - 여러 작업이 묶인 트랜잭션으로 요청이 간 경우가 실패할 경우 개발자가 직접 롤백 처리를 해주어야 합니다.
        - 장점
            - 충돌이 안난다는 가정하에서 동시 요청에 대해서 처리 성능이 좋습니다.
        - 단점
            - 잦은 충돌이 일어나는경우 롤백처리에 대한 비용이 많이 들어 오히려 손해를 볼 수 있습니다.
            - 롤백 처리를 구현하는게 복잡할 수 있습니다.

---

- **DB 락에 대해 설명해주세요**
    
    DB Lock은 트랜잭션 처리의 순차성을 보장하기 위한 방법입니다.
    
    공유락 : (LS, Shared Lock) Read Lock라고도 하는 공유학은 트랜잭션이 읽기를 할 때 사용하는 락이며 데이터를 읽기만하기 때문에 같은 공유락끼리는 동시에 접근이 가능합니다.
    
    베타락: (LX, Exclusive Lock) Write Lock라고도 하는 베타락은 데이터를 변경할 때 사용하는 락입니다. 트랜잭션이 완료될때까지 유지되며, 베타락이 끝나기 전까지 어떠한 접근도 허용하지 않습니다.
    

---

- **RDBMS와 NoSQL의 정의, 장/단점에 대해 설명해주세요**
    
    RDBMS는 모든 데이터를 2차원 테이블 형태로 표현합니다.
    
    - 장점: 스키마에 맞춰 데이터를 관리하기 때문에 데이터의 정합성을 보장할 수 있다.
    - 단점: 시스템이 커질 수록 쿼리가 복잡해지고 성능이 저하되며 Scale-out이 어렵다(Sacle-up만 가능)
    
    NoSQL은 RDBMS와 반대로 데이터간의 관계를 정의하지 않고, 스키마가 없어 좀 더 자유롭게 데이터를 관리할 수 있으며, 컬렉션이라는 형태로 데이터를 관리합니다. 트랜잭션 적용되지 않는다.
    
    - 장점: 스키마 없이 Key-Value 형태로 데이터를 관리해 자유롭게 데이터를 관리할 수 있으며 데이터 분산이 용이하여 성능 향상을 위한 Scale-up뿐만 아닌 sacle-out또한 가능하다.
    - 단점: 데이터 중복이 발생할 수 있고, 중복된 데이터가 변경될 경우 수정을 모든 컬렉션에서 수행해야 하며 스키마가 존재하지 않기에 데이터 구조를 보장하지 않아 데이터 구조 결정이 어려울 수 있다.

---

- **RDBMS와 NoSQL은 어느 경우에 적합한가요?**
    
    RDBMS는 데이터 구조가 명확하고, 변경 될 여지가 없으며 스키마가 중요한 경우 사용하는 것이 좋습니다. 또한 중복된 데이터가 없어(데이터 무결성)변경이 용이하기 때문에 관계를 맺고 있는 데이터가 자주 변경이 이루어지는 시스템에 적합합니다.
    
    NoSQL은 정확한 데이터 구조를 알 수 없고 데이터가 변경/확장 될 수 있는 경우 사용하는 것이 좋습니다. 또한 단점에서도 명확하듯 데이터 중복이 발생할 수 있으며 중복된 데이터가 변경시 모든 컬렉션에서 수정해야 하기 때문에 Update가 많이 이루어지지 않는 시스템에 좋으며 Scale-out이 가능하다는 장점을 활용해 막대한 데이터를 저장해야 해서 Scale-out해야 하는 시스템에 적합합니다. 
    

---

- **Index에 대해 설명해주시고, 장/단점에 대해 아는대로 말해주세요.**
    - 정의
        - 인덱스란 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조
    - 특징
        - 인덱스는 항상 정렬된 상태를 유지하기 때문에 원하는 값을 검색하는데 빠릅니다.
        - 데이터의 수정, 삭제시 먼저 데이터를 조회한뒤 작업을 진행하기에 성능에 영향을 미친다.(좋아지고 나빠지고는 데이터 베이스에 따라 다르다.)
        - 인덱스는 데이터의 저장 성능을 희생하는 대신 데이터의 검색 속도를 높이는 기능이라 할 수 있습니다.
        - 인덱스를 사용하는 상황에서 update와 delete를 사용할 경우 기존의 인덱스를 삭제하지 않고 사용하지 않음으로 변경한다. 그러므로 update와 delete가 수행될경우 인덱스가 많아져 성능이 떨어질수 있다.
    - 장점
        - 테이블을 조회하는 속도와 그에 따른 성능을 향상시킬 수 있다.
        - 전반적인 시스템의 부하를 줄일 수 있다.
    - 단점
        - 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장공간이 필요하다.
        - 인덱스를 관리하기 위해 추가 작업이 필요하다.
        - 인덱스를 잘못 사용할 경우 오히려 성능이 저하되는 역효과가 발생할 수 있다.

---

- **DBMS는 index를 어떻게 관리하고 있는지 말해주세요.**
    - B+Tree 인덱스 자료 구조
        
        자식노드가 2개 이상인 B-Tree를 개선시킨 자료구조이며 BTree 리프노드들은 LinkedList로 연결하여 순차 검색을 용이하게 합니다. 해시 테이블보다 나쁜 O(log2N)의 시간 복잡도를 갖기만 일반적으로 사용되는 자료구조입니다.
        
    - 해시테이블
        - 컬럼의 값으로 생성된 해시를 기반으로 인덱스를 구현합니다.
        - 시간복잡도가 O(1)이라 검색이 매우 빠릅니다.
        - 부등호와 같은 연속적인 데이터를 위한 순차검색이 불가능하기 때문에 사용에 적합하지 않습니다.

---

- **옵티마이저에 대해 설명해주세요.**
    
    옵티마이저는 SQL을 가장 빠르고 효율적으로 수행할 최적의 경로를 생성해주는 DBMS 내부의 핵심 엔진입니다.
    
    컴퓨터의 두뇌가 CPU인 것 처럼 DBMS의 두뇌는 옵티마이저라고 할 수 있습니다. 개발자가 SQL을 작성하고 실행하면 즉시 실행되는 것이 아니라 옵티마이저라는 곳에서 최고의 효율을 갖는 실행계획을 판별한 후 그 실행계획에 따라 쿼리를 수행하게 되는 것입니다.
    

---

- **Nested Loops join(중첩 루프 조인)의 정의, 동작 방식, 언제 사용하는지, 특징에 대해서 설명해주세요**
    - 정의
        - 2개 이상 테이블에서 하나의 테이블을 기준으로 순차적으로 상대방 Row를 결합하여 원하는 결과를 추출하는 방식을 의미한다.
    - 동작 방식
        - Driving Table(선행 테이블)의 처리 범위를 하나씩 액세스 하면서 추출된 값으로 Driven Table(후행 테이블)을 조인하는 방식을 동작
    - 언제 사용하는가?
        - 한쪽 입력이 작고(Driving Table), 다른 한쪽 입력이 크면서 join열에 인덱스가 있는 경우(Driven Table)사용합니다.(I/O연산과 비교 연산이 가장 적게 필요하기 때문입니다.)
    - 특징
        - 선행 테이블의 결과를 통해 후행 테이블을 액세스 할 때 랜덤 I/O가 발생한다.
        - 인덱스에 의한 랜덤 액세스에 기반하므로 대량 데이터 처리시 적합하지 않다.
        - 메모리 사용량이 가장 적다.
        - 순차적으로 처리한다.
        - 순차적으로 처리하기 때문에 안쪽 테이블에 인덱스가 필요하다.

---

- **Merge Join / Sort Merge Join (정렬 병합)의 정의, 동작방식, 해당 조인을 사용하는 경우 특징에 대해서 설명해주세요**
    - 정의
        - 양 테이블을 각각 접근하여 결과를 정렬하고, 정렬한 결과를 Scan해가면서 연결 조건을 Merge하는 방식
    - 동작 방식
        - 각 테이블에 대해서 동시에 독립적인 데이터를 먼저 읽어 들인다.
        - 읽혀진 각 테이블의 데이터를 조인을 위한 연결고리에 대하여 정렬을 수행한다.
        - 정렬이 모두 끝난 후에 조인 작업이 수행한다.
    - 해당 조인을 사용하는 경우
        - 두 join 열을 미리 정렬된 상태로 가져올 수 있는 경우
        - 연결 고리에 인덱스가 전혀 없는 경우
        - 대용량 자료를 조인할때 유리한 경우
        - 조인 조건으로 범위 비교 연산자가 사용된 경우
        - 인덱스 사용에 따른 랜덤 액세스의 오버헤드가 많은 경우
    - 특징
        - 동시 처리
        - 독립적
        - 인덱스 유무는 중요하지 않다.
        - 정렬에 따라 메모리 사용량이 증가.

---

- **Hash Join의 정의 동작방식 사용되는 경우 종류에 대해서 설명해주세요**
    - 정의
        - 두 테이블 중 하나를 Hash Table로 선정하여, 테이블의 key 값을 hash 알고리즘으로 비교하여 조인을 수행하는 방식
        - Sort-Merge 조인은 소트의 부하가 많이 발생하여, 이를 보완하기 위한 방법으로 Sort 대신 해쉬값을 이용하는 조인
        - Build Input을 읽어 해쉬 영역에 해쉬 테이블을 생성하고 Probe Input을 읽어 해쉬 테이블을 탐색하면서 조인하는 방식
    - 동작 방식
        - 둘 중 작은 집합(Build Input)을 읽어 해쉬 영역(Hash Area)에 해시 테이블(Hash Map)을 생성
            - 해시 함수에서 리턴 받은 버킷 주소로 찾아가 해시 체인에 엔트리를 연결
        - 반대쪽 큰 집합을 읽어 해시 테이블을 탐색하면서 join
        - 해시 함수에서 리턴 받은 버킷 주소로 찾아가 해시 체인을 스캔하면서 데이터를 찾는다.

---

- **select 쿼리의 수행 순서에대해 설명해주세요**
    1. From절 
        
        From, On, Join
        
        - From : 각 테이블을 확인한다.
        - On : Join 조건을 확인 한다.
        - Join : Join이 실행되어 데이터가 set으로 모아지게 된다. 서브쿼리도 함께 포함되어 임시 테이블을 만들 수 있게 도와준다.
    2. Where절 
        - 데이터셋을 형성하게 되면 where의 조건이 개별 행에 적용된다. Where절의 제약 조건은 From절로 가져온 테이블에 적용될 수 있다.
    3. Group By
        - Where의 조건 적용후 나머지 행은 Group by절에 지정된 공통 값을 기준으로 그룹화된다. 쿼리에 집계 기능이 있는 경우에만 이 기능을 사용해야 한다.
    4. Having
        - Group By절이 쿼리에 있을 경우 Having 절의 제약 조건이 그룹화된 행에 적용된다.
    5. Select
        - SELECT 절은 여러 조건들을 처리한 후 남은 데이터에서 어떤 열을 출력해줄지 선택한다
    6. Order By
        - 어떤 열까지 출력할지 정했다면 행의 순서를 어떻게 보여줄지 정렬 해주는 절이 Order By이다.
    7. Limit
        - Limit절은 결과중 몇개의 행을 보여줄지 선택한다.

---

- **트리거에 대해 설명해주세요**
    - 트리거는 특정 테이블에 대한 이벤트에 반응해 Insert, Delete, UPdate와 같은 DML 문이 수행되었을 때, 데이터베이스에서 자동으로 동작하도록 작성된 프로그램입니다.
    - 사용자가 직접 호출하는 것이 아닌, 데이터베이스에서 자동적으로 호출한다는 것이 가장 큰 특징입니다.

---

- **SQL Injection이 무엇인지 설명해주세요**
    - SQL Injection이란 공격자가 악의적인 의도를 갖는 SQL 구문을 삽입하여 데이터베이스를 비정상적으로 조작하는 코드 인젝션 공격기법입니다.

---

- **SQL Injection을 방어 및 방지하기 위한 방법에 대해 설명해주세요**
    1. 입력값을 검증하여 사용자의 입력이 쿼리에 동적으로 영향을 주는 경우 입력된 값이 개발자가 의도한 값(유효값)인지 검증합니다.
    2. 저장 프로시저를 사용합니다.
        
        ⚠️ 저장 프로시저란 사용하고자 하는 Querydp 미리 형식을 지정하는 것을 말한다. 지정된 형식의 데이터가 아니면 Query가 실행되지 않기 때문에 보안성이 크게 향상된다.
        

---

- **DB 튜닝이 무엇인지 그리고 튜닝의 3단계에 대해 설명해주세요**
    - DB튜닝이란 DB의 구조, DB 자체, 운영체제 등을 조정하여 DB 시스템의 전체적인 성능을 개선하는 작업을 말합니다.
    - 튜닝은 DB설계튜닝 → DBMS 튜닝 → SQL 튜닝 단계로 진행할 수 있습니다.

---

- **Delete, Truncate, Drop의 차이를 설명해주세요**
    - Delete는 데이터는 지우지만 테이블 용량은 줄어들지 않고 원하는 데이터만 골라서 지울 수 있습니다. 삭제후 되돌릴 수 있습니다.
    - Truncate는 전체 데이터를 한번에 삭제하는 방식입니다. 테이블 용량이 줄어들고 인덱스 등도 삭제되지만 테이블은 삭제할 수 없고 삭제후 되돌릴 수 없습니다.
    - Drop은 테이블 자체를 완전히 삭제하는 방식(공간, 인덱스, 객체 모두 삭제)입니다. 삭제후 되돌딜 수 없습니다.

---

- **데이터베이스 클러스터링과 리플리케이션의 차이에 대해서 설명해주세요**
    - 클러스터링
        - 정의
            - 여러개의 DB를 수평적인 구조로 구축하는 방식입니다. 동기방식으로 사용됩니다.
        - 장점
            - DB간의 데이터를 동기화하여 항상 일관성있는 데이터를 얻을 수 있습니다.
            - 1개의 DB가 죽어도 다른 DB가 살아 있어 시스템을 장애없이 운영할 수 있다.(높은 가용성)
            - 기존의 하나의 DB서버에 몰리던 부하를 여러곳으로 분산시킬 수 있다.(로드밸런싱)
        - 단점
            - 저장소 하나를 공유하면 병목현상이 발생할 수 있다.
            - 서버를 동시에 운영하기 위한 비용이 많이 든다.
    - 리플리케이션
        - 정의
            - 여러개의 DB를 권한에 따라 수직적인 구조로 구축하는 방식입니다. 비동기 방식으로 사용됩니다.
        - 장점
            - 읽기 작업이 다수를 이룰때 Replication만으로도 충분히 성능을 높일 수 있습니다.
            - 비동기 방식으로 운영되며 지연 시간이 거의 없습니다.
        - 단점
            - 노드들 간 데이터 동기화가 보장되지 않아 일관성있는 데이터를 얻지 못할 수 있습니다.
            - Master DB가 다운되면 복구밑 대처가 까다롭습니다.

---

- **파티셔닝의 개념과 목적에 대해서 설명해주세요**
    - 개념
        - 큰 테이블이나 index를 관리하기 쉬운 partition이라는 작은 단위로 물리적으로 분할하는 것을 의미합니다.
        - 파티셔닝 기법을 통해서 데이터베이스를 분산처리하여 성능이 저하되는 것을 방지할수 있습니다.
    - 목적
        - 성능
            - 특정 DML과 Query의 성능 향상이 가능케 합니다.
            - 주로 대용량 Data Write하는 환경에 효율적입니다.
            - 특히 full scan에서 데이터 access의 범위를 줄여 성능 향상을 가져옵니다.
        - 가용성
            - 물리적인 파티셔닝으로 인해 전체 데이터의 훼손 가능성이 줄어들고 데이터 가용성이 향상됩니다.
            - table의 partition 단위로 Dist I/O를 분산하여 경합을 줄이기 때문에 Update성능을 향상시킵니다.
        - 관리 용이성
            - 큰 테이블을 제거하여 관리를 쉽게 해줍니다.

---

- **파티셔닝의 장점과 단점에 대해서 설명해주세요**
    - 장점
        - 관리적인 측면
            - partition 단위 백업 추가, 삭제 변경
            - partition 단위로 I/O분산이 가능하여 Update 성능을 향상시킨다.
        - 성능적인 측면
            - partition 단위 조회 및 DML 수행
            - 필요한 부분만 탐색해 성능이 증가한다.
            - Full Scan에서 데이터 Access의 범위를 줄여 성능 향상을 가져온다.
            - 필요한 데이터만 빠르게 조회할수 있기에 쿼리 자체가 가볍다.
    - 단점
        - table간 join에 대한 비용이 증가한다.
        - table과 index를 같이 파티셔닝 해야 한다.

---

- **파티셔닝의 종류에 대해서 설명해주세요**
    - 하드웨어 장치를 업그레이드하는 수직 파티셔닝과 샤딩과 동일한 개념인 수평 파티셔닝이 존재합니다.
    - 수직 파티셔닝과 수평 파티셔닝의 차이는 수직 파티셔닝 즉 샤딩은 DB서버를 분할한다는 것이고 수평 파티셔닝은 DB서버 내에서 테이블을 분할한다는 것입니다.

---

- **샤딩의 정의및 장 단점에 대해서 설명해주세요**
    - 정의
        - 샤딩은 각 DB서버에서 데이터를 분할하여 저장하는 방식을 의미합니다.
        - 해당 데이터에 접근할 때는 샤딩키를 사용하여 동적으로 DB서버를 매칭하는 과정이 필요합니다.
    - 장점
        - 샤딩을 사용하면 DB의 트래픽을 분산시킬 수 있는 역할을 수행할 수 있습니다. 추가적으로 DB의 테이블 크기를 줄이게 되고 DB의 장애를 국소화 시키는 부수적인 역할도 합니다.
    - 단점
        - 샤딩은 구현이 복잡하고 잘못 수행시 데이터가 손실되거나 테이블이 손상되거나 부하의 불균형이 발생할 수 있습니다. 또한 샤딩 전 원래 DB 구조로 되돌리는 작업은 매우 복잡하고 어렵다는 단점이 존재합니다.

---

- **샤딩의 종류와 특징에 대해서 말씀해주세요**
    - 모듈러 샤딩
        - 정의
            - PK를 모듈러 연산한 결과로 DB를 라우팅하는 방식입니다.
        - 특징
            - 레인지 샤딩에 비해 데이터가 균일하게 분산됩니다.
            - DB를 추가 증설하는 과정에서 이미지 적대된 데이터의 재정렬이 필요합니다.
        - 정리
            - 데이터가 늘어남에 따라 샤딩을 추가적으로 해야하는 상황이 자주 생기면 큰 부하가 발생합니다. 그렇기 때문에 모듈러 샤딩은 데이터량이 일정 수준에서 유지될 것으로 예상되는 데이터 성격을 가진 곳에 적용할 때 어울립니다.
            - 데이터가 균일하게 분산된다는 점은 트래픽을 안정적으로 소화하면서도 DB리소스를 최대한 활용할 수 있다는 것을 의미합니다.
    - 레인지 샤딩
        - 정의
            - PK의 범위를 기준으로 DB를 특정하는 방식입니다.
        - 특징
            - 모듈러 샤딩에 비해 기본적으로 증설에 재정렬 비용이 들지 않습니다.
            - 일부 DB에 데이터가 몰릴 수 있습니다.
    - 디렉토리 샤딩
        - 정의
            - 별도의 조회 테이블을 사용해서 샤딩을 하는 경우입니다.
        - 특징
            - 샤딩에 사용되는 시스템이나 알고리즘을 사용할 수 있습니다.
            - 샤드를 동적으로 추가하는 것도 비교적으로 쉽습니다.
            - 모든 읽기 및 쓰기 쿼리 전에 조회 테이블을 참조해야 하므로 오버헤드가 발생합니다.

---

- **샤딩은 언제 사용하면 좋은지 말씀해주세요**
    - 조회할 레코드를 줄이기위해서는 일반적을 파티셔닝을 적용할 수 있습니다. 장애를 방지하고 DB부하를 분산시키기 위한 목적으로는 복제를 사용할 수 있습니다. DB서버에도 MSA를 적용하고 분산 트랜잭션으로 잘 풀어나가는 방법도 존재합니다. 그러나 이렇게 해도 부하를 줄이지 못할때는 샤딩을 사용하는 것이 좋습니다. 또한 사용자가 많고 MasterDB하나로 도저히 받지 못할때도 샤딩을 사용할 수 있습니다.